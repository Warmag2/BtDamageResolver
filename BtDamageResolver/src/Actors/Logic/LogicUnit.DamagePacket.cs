using System;
using System.Collections.Generic;
using System.Linq;
using Faemiyah.BtDamageResolver.Actors.Logic.Entities;
using Faemiyah.BtDamageResolver.Actors.Logic.Interfaces;
using Faemiyah.BtDamageResolver.Api.Entities;
using Faemiyah.BtDamageResolver.Api.Enums;

namespace Faemiyah.BtDamageResolver.Actors.Logic;

/// <summary>
/// Partial class of unit logic which governs all application of damage packets to unit paper dolls.
/// </summary>
public partial class LogicUnit
{
    /// <summary>
    /// Generate damage packets based on the attack and calculated damage.
    /// </summary>
    /// <param name="damageReport">The damage report to append to.</param>
    /// <param name="target">The target unit logic.</param>
    /// <param name="combatAction">The combat action.</param>
    /// <param name="damage">Total calculated and transformed damage.</param>
    /// <returns>A list of damage packets generated by the attack parameters.</returns>
    protected virtual List<DamagePacket> ResolveDamagePackets(DamageReport damageReport, ILogicUnit target, CombatAction combatAction, int damage)
    {
        // Heat weapons are cluster weapons for vulnerable unit types
        if (combatAction.Weapon.HasSpecialDamage(SpecialDamageType.HeatConverted, out _) && !target.IsHeatTracking())
        {
            damageReport.Log(new AttackLogEntry { Type = AttackLogEntryType.Information, Context = "Heat weapon acts as a cluster weapon against targeted unit" });
            return Clusterize(combatAction.Weapon.ClusterSize, damage, combatAction.Weapon.SpecialDamage);
        }

        if (combatAction.Weapon.HasFeature(WeaponFeature.Cluster, out _))
        {
            return Clusterize(combatAction.Weapon.ClusterSize, damage, combatAction.Weapon.SpecialDamage);
        }

        if (combatAction.Weapon.HasFeature(WeaponFeature.Rapid, out _))
        {
            // Rapid-fire weapons may already have dealt more damage than the individual instance, clusterize to units of the actual damage value
            return Clusterize(combatAction.Weapon.Damage[combatAction.RangeBracket], damage, combatAction.Weapon.SpecialDamage);
        }

        // Clustrerize to a single packet
        return Clusterize(damage, damage, combatAction.Weapon.SpecialDamage);
    }

    /// <summary>
    /// Clusterize a hit.
    /// </summary>
    /// <param name="clusterSize">The cluster size.</param>
    /// <param name="totalDamage">The total damage.</param>
    /// <param name="specialDamage">Special damage entry, if any.</param>
    /// <returns>A list of damage packets representing the clusterization.</returns>
    protected List<DamagePacket> Clusterize(int clusterSize, int totalDamage, List<SpecialDamageEntry> specialDamage)
    {
        var damagePackets = new List<DamagePacket>();
        var first = true;

        // Some weapons deal no damage but have an effect. In these cases we still have to produce the effect, if nothing else.
        if (totalDamage == 0 && specialDamage.Exists(s => s.Type != SpecialDamageType.None))
        {
            damagePackets.Add(
                new DamagePacket
                {
                    Damage = 0,
                    SpecialDamageEntries = specialDamage.Select(s => new SpecialDamageEntry { Data = MathExpression.Parse(s.Data).ToString(), Type = s.Type }).ToList(),
                });

            return damagePackets;
        }

        while (totalDamage > 0)
        {
            var currentClusterSize = Math.Clamp(totalDamage, 1, clusterSize);

            // Only the first cluster hit applies the special damage entry, if any, so clustering does not multiply special damage
            var clusterSpecialDamageEntry = first
                ? specialDamage.Select(s => new SpecialDamageEntry { Data = MathExpression.Parse(s.Data).ToString(), Type = s.Type }).ToList()
                : new List<SpecialDamageEntry>
                {
                    new()
                };

            damagePackets.Add(new DamagePacket(currentClusterSize, clusterSpecialDamageEntry));
            totalDamage -= currentClusterSize;

            first = false;
        }

        return damagePackets;
    }
}