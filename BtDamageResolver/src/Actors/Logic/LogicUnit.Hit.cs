using Faemiyah.BtDamageResolver.ActorInterfaces.Extensions;
using Faemiyah.BtDamageResolver.Actors.Logic.Entities;
using Faemiyah.BtDamageResolver.Api.Entities;
using Faemiyah.BtDamageResolver.Api.Enums;
using Faemiyah.BtDamageResolver.Api.Extensions;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace Faemiyah.BtDamageResolver.Actors.Logic
{
    public partial class LogicUnit
    {
        /// <summary>
        /// Resolves the hits generated by an attack and generates the appropriate combat actions.
        /// </summary>
        /// <param name="targetDamageReport">The damage report of the target.</param>
        /// <param name="target">The target unit logic.</param>
        /// <returns>A list of hits produced by this units attack.</returns>
        private async Task<List<CombatAction>> ResolveHits(DamageReport targetDamageReport, ILogicUnit target)
        {
            var hits = new List<CombatAction>();

            foreach (var weapon in Unit.Weapons.Where(w => w.State == WeaponState.Active))
            {
                var combatAction = await ResolveHit(targetDamageReport, target, weapon);

                // Transform combat actions if necessary
                target.TransformCombatAction(targetDamageReport, combatAction);

                // Calculate heat
                ResolveHeat(targetDamageReport, combatAction);

                // Calculate ammo
                ResolveAmmo(targetDamageReport, combatAction);

                // When we return from here, we only have to consider combat actions which actually happened.
                // Note that hitting is not necessary, as charges and DFAs still hurt the initiator even if they miss.
                if (combatAction.ActionHappened)
                {
                    hits.Add(combatAction);
                }
            }

            return hits;
        }

        private async Task<CombatAction> ResolveHit(DamageReport targetDamageReport, ILogicUnit target, WeaponEntry weaponEntry)
        {
            var weapon = await LogicHelper.GrainFactory.GetWeaponRepository().Get(weaponEntry.WeaponName);

            var (targetNumber, rangeBracket) = ResolveHitModifier(targetDamageReport.AttackLog, target, weapon, weaponEntry.Mode);

            // Weapons which cannot hit at all, do not fire.
            if (targetNumber > 12)
            {
                targetDamageReport.Log(new AttackLogEntry { Type = AttackLogEntryType.Information, Context = $"{weapon.Name} cannot hit and does not fire" });
            }
            {
                targetDamageReport.Log(new AttackLogEntry { Type = AttackLogEntryType.Fire, Context = $"{weapon.Name}" });
            }

            var hitRoll = LogicHelper.Random.D26();
            targetDamageReport.Log(new AttackLogEntry { Type = AttackLogEntryType.DiceRoll, Context = "To-hit roll", Number = hitRoll });

            var hitHappened = hitRoll >= targetNumber;

            if (hitHappened)
            {
                targetDamageReport.Log(new AttackLogEntry { Type = AttackLogEntryType.Hit, Context = weapon.Name });
            }
            else
            {
                targetDamageReport.Log(new AttackLogEntry { Type = AttackLogEntryType.Miss, Context = weapon.Name });
            }

            return new CombatAction
            {
                ActionHappened = true,
                HitHappened = hitHappened,
                MarginOfSuccess = hitRoll - targetNumber,
                RangeBracket = rangeBracket,
                UnitType = Unit.Type,
                Troopers = Unit.Troopers,
                Weapon = weapon,
                WeaponMode = weaponEntry.Mode
            };
        }

        /// <inheritdoc />
        public void TransformCombatAction(DamageReport targetDamageReport, CombatAction combatAction)
        {
            // Streak hits do not actually fire if they would not hit.
            if (combatAction.Weapon.SpecialFeatures[combatAction.WeaponMode].HasFeature(WeaponFeature.Streak, out _))
            {
                if (!combatAction.HitHappened)
                {
                    combatAction.ActionHappened = false;
                    targetDamageReport.Log(new AttackLogEntry { Context = $"{combatAction.Weapon.Name} does not obtain lock and does not fire", Type = AttackLogEntryType.Information });
                }
            }

            // Single missile handling. If AMS destroys the only missile, this causes a total miss.
            // In this type of a case, streak missiles such as a hypothetical SRM-1 would still have fired.
            if (combatAction.Weapon.Type == WeaponType.Missile && Unit.HasFeature(UnitFeature.Ams) && combatAction.HitHappened && (combatAction.Weapon.Damage[combatAction.RangeBracket] == 1 || !combatAction.Weapon.SpecialFeatures[combatAction.WeaponMode].HasFeature(WeaponFeature.Cluster, out _)))
            {
                if (combatAction.Weapon.SpecialFeatures[combatAction.WeaponMode].HasFeature(WeaponFeature.AmsImmune, out _))
                {
                    targetDamageReport.Log(new AttackLogEntry { Type = AttackLogEntryType.Information, Context = "Missile is immune to AMS defenses" });
                }
                else
                {
                    var singleMissileDefenseRoll = LogicHelper.Random.NextPlusOne(6);
                    targetDamageReport.Log(new AttackLogEntry { Type = AttackLogEntryType.DiceRoll, Context = "Ams defense roll against single missile", Number = singleMissileDefenseRoll });
                    if (singleMissileDefenseRoll >= 4)
                    {
                        combatAction.HitHappened = false;
                        targetDamageReport.Log(new AttackLogEntry { Type = AttackLogEntryType.Information, Context = "Missile is destroyed by AMS" });
                    }
                    else
                    {
                        targetDamageReport.Log(new AttackLogEntry { Type = AttackLogEntryType.Information, Context = "Missile is not destroyed by AMS" });
                    }

                    targetDamageReport.SpendAmmoDefender("AMS", 1);
                }
            }
        }
    }
}
